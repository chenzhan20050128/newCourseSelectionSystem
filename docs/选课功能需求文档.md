# 选课功能需求文档

## 1. 功能概述

实现学生选课功能，允许学生选择课程，系统需要验证各种业务规则，确保选课操作的合法性和数据一致性。

## 2. 业务逻辑考虑点

### 2.1 基础验证

#### 2.1.1 学生身份验证
- **验证点**：学生ID必须存在且有效
- **数据来源**：`students` 表
- **验证逻辑**：
  - 检查 `student_id` 是否存在于 `students` 表中
  - 验证学生状态是否正常（如有状态字段）
- **错误提示**：`"学生不存在或状态异常"`

#### 2.1.2 课程存在性验证
- **验证点**：课程ID必须存在且有效
- **数据来源**：`courses` 表
- **验证逻辑**：
  - 检查 `course_id` 是否存在于 `courses` 表中
- **错误提示**：`"课程不存在或未开放选课"`

### 2.2 重复选课检查

#### 2.2.1 同一课程重复选课
- **验证点**：学生不能重复选择同一门课程
- **数据来源**：`enrollments` 表
- **验证逻辑**：
  - 查询 `enrollments` 表，检查是否存在 `student_id` 和 `course_id` 的组合
  - 考虑 `status` 字段：如果状态为 `"已选"` ，则不允许重复选课
- **错误提示**：`"您已经选择过该课程"`

### 2.3 时间冲突检查（核心业务逻辑）

#### 2.3.1 课程节次冲突检测
- **验证点**：学生已选课程的上课时间最好不能与新选课程的上课时间冲突
- **数据来源**：
  - `enrollments` 表：获取学生已选的所有课程ID
  - `course_sessions` 表：获取已选课程和新选课程的所有节次信息
- **验证逻辑**：
  1. 查询学生所有状态为 `"已选"` 的选课记录，获取 `course_id` 列表
  2. 查询这些课程的所有 `course_sessions` 记录
  3. 查询新选课程的所有 `course_sessions` 记录
  4. 比较节次是否冲突：
     - 冲突条件：同一 `weekday`（星期），且时间段有重叠
     - 时间段重叠判断：`(new_start <= old_end) && (new_end >= old_start)`
  5. 如果存在冲突，返回冲突的课程和节次信息
- **错误提示**：`"选课时间冲突：与课程[课程名]在[星期X]第[开始节]-[结束节]节冲突"`
注意 如果冲突的话是能选的 ！ 只是要在返回的dto里面加一个提示 warn 搞一个String类型的

### 2.4 课程容量限制

#### 2.4.1 容量验证逻辑
- **验证点**：课程当前选课人数不能超过最大容量
- **数据来源**：
  - `courses` 表的 `capacity` 字段
  - `enrollments` 表：统计 `course_id` 对应且 `status='已选'` 的记录数
- **验证逻辑**：
  1. 查询课程的 `capacity` 值
  2. 统计当前已选人数：`SELECT COUNT(*) FROM enrollments WHERE course_id = ? AND status = '已选'`
  3. 比较：`当前人数 >= capacity` 则不允许选课
- **错误提示**：`"课程已满，当前选课人数：[当前人数]/[最大容量]"`
这个课程当前选课人数不能超过最大容量条件如果不满足的话是硬性不能选的！ 跟课程节次冲突不一样

### 2.5 选课状态管理

#### 2.5.1 状态字段说明
- **当前状态值**：根据 `insertTable.sql`，`status` 字段可能的值包括：
  - `"已选"`：学生已选择该课程
  - `"已退选"`：学生已退选（可能需要保留历史记录）
  - `"已完成"`：课程已完成（有最终成绩）
  - 其他可能的状态：`"进行中"`、`"已取消"` 等

#### 2.5.2 选课时的状态设置
- **初始状态**：新选课时，`status` 应设置为 `"已选"`
- **时间戳**：`enrolled_at` 字段应设置为当前系统时间

## 3. 事务处理

### 3.1 事务边界
- **事务开始**：选课业务逻辑开始
- **事务提交**：所有验证通过，成功插入选课记录后
- **事务回滚**：任何验证失败或插入失败时

### 3.2 事务隔离级别
- **建议**：使用 `REPEATABLE_READ` 
- **原因**：
  - 防止并发选课时出现脏读
  - 确保容量检查的准确性（避免超卖）

### 3.3 并发控制
- **问题场景**：多个学生同时选择同一门容量有限的课程
- 直接使用 `REPEATABLE_READ`  控制并发即可 不用加锁